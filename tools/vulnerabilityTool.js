const axios = require('axios');

/**
 * Vulnerability Scanner Tool
 * Performs safe, non-destructive vulnerability tests
 * - Security headers validation
 * - CORS policy testing
 * - XSS reflection tests (safe patterns only)
 * - SQL injection indicators
 */

class VulnerabilityTool {
  constructor() {
    this.name = 'VulnerabilityTool';
    this.findings = [];
  }

  /**
   * Run all vulnerability scans
   * @param {string} url - Target URL
   * @param {Object} reconData - Data from reconnaissance
   * @returns {Promise<Object>} Vulnerability scan results
   */
  async scan(url, reconData = null) {
    try {
      console.log(`[${this.name}] Starting vulnerability scan on: ${url}`);

      this.findings = [];
      const results = {
        url: url,
        timestamp: new Date().toISOString(),
        vulnerabilities: [],
        riskLevel: 'Low',
        testsPerformed: []
      };

      // Test 1: Security Headers
      await this.testSecurityHeaders(url, reconData);
      results.testsPerformed.push('Security Headers');

      // Test 2: CORS Configuration
      await this.testCORS(url);
      results.testsPerformed.push('CORS Policy');

      // Test 3: Input Reflection (XSS indicators)
      await this.testInputReflection(url);
      results.testsPerformed.push('Input Reflection');

      // Test 4: SQL Injection Indicators
      await this.testSQLInjectionIndicators(url);
      results.testsPerformed.push('SQL Injection Indicators');

      // Test 5: Cookie Security
      await this.testCookieSecurity(url);
      results.testsPerformed.push('Cookie Security');

      // Compile results
      results.vulnerabilities = this.findings;
      results.riskLevel = this.calculateRiskLevel(this.findings);

      console.log(`[${this.name}] Scan completed. Found ${this.findings.length} potential issues`);
      return results;

    } catch (error) {
      console.error(`[${this.name}] Error during scan:`, error.message);
      return {
        url: url,
        timestamp: new Date().toISOString(),
        error: error.message,
        vulnerabilities: this.findings
      };
    }
  }

  /**
   * Test for missing or weak security headers
   */
  async testSecurityHeaders(url, reconData) {
    try {
      let headers = {};

      if (reconData && reconData.securityHeaders) {
        headers = reconData.securityHeaders;
      } else {
        const response = await axios.get(url, {
          validateStatus: () => true,
          timeout: 5000
        });
        headers = {
          contentSecurityPolicy: response.headers['content-security-policy'],
          strictTransportSecurity: response.headers['strict-transport-security'],
          xFrameOptions: response.headers['x-frame-options'],
          xContentTypeOptions: response.headers['x-content-type-options']
        };
      }

      if (!headers.contentSecurityPolicy) {
        this.addFinding('Missing Content-Security-Policy', 'Medium',
          'No CSP header found. Application may be vulnerable to XSS attacks.');
      }

      if (!headers.strictTransportSecurity) {
        this.addFinding('Missing HSTS', 'Medium',
          'No Strict-Transport-Security header. HTTPS connections may be downgraded.');
      }

      if (!headers.xFrameOptions) {
        this.addFinding('Missing X-Frame-Options', 'Medium',
          'Application may be vulnerable to clickjacking attacks.');
      }

      if (!headers.xContentTypeOptions) {
        this.addFinding('Missing X-Content-Type-Options', 'Low',
          'MIME-sniffing attacks may be possible.');
      }

    } catch (error) {
      console.error(`[${this.name}] Security headers test failed:`, error.message);
    }
  }

  /**
   * Test CORS configuration
   */
  async testCORS(url) {
    try {
      const response = await axios.options(url, {
        headers: {
          'Origin': 'https://evil-site.com',
          'Access-Control-Request-Method': 'GET'
        },
        validateStatus: () => true,
        timeout: 5000
      });

      const allowOrigin = response.headers['access-control-allow-origin'];
      const allowCredentials = response.headers['access-control-allow-credentials'];

      if (allowOrigin === '*') {
        if (allowCredentials === 'true') {
          this.addFinding('Insecure CORS Configuration', 'High',
            'CORS allows any origin (*) with credentials enabled. Major security risk.');
        } else {
          this.addFinding('Permissive CORS Configuration', 'Low',
            'CORS allows any origin (*). May expose sensitive data.');
        }
      }

      if (allowOrigin && allowOrigin.includes('evil-site.com')) {
        this.addFinding('CORS Reflects Arbitrary Origins', 'Medium',
          'CORS policy reflects the requesting origin without validation.');
      }

    } catch (error) {
      console.error(`[${this.name}] CORS test failed:`, error.message);
    }
  }

  /**
   * Test for input reflection (potential XSS)
   * Uses safe test patterns only
   */
  async testInputReflection(url) {
    try {
      const testPayload = '<script>alert("XSS")</script>';
      const safeMarker = 'PENTEST_MARKER_12345';

      const parsedUrl = new URL(url);
      parsedUrl.searchParams.set('q', safeMarker);

      const response = await axios.get(parsedUrl.toString(), {
        validateStatus: () => true,
        timeout: 5000
      });

      const body = response.data ? response.data.toString() : '';

      if (body.includes(safeMarker)) {
        this.addFinding('Input Reflection Detected', 'Medium',
          `User input is reflected in the response. Potential XSS vulnerability if not properly sanitized.`);
      }

    } catch (error) {
      console.error(`[${this.name}] Input reflection test failed:`, error.message);
    }
  }

  /**
   * Test for SQL injection error messages
   * Uses safe patterns that don't exploit, just detect
   */
  async testSQLInjectionIndicators(url) {
    try {
      const testPatterns = ["'", "1' OR '1'='1", "admin'--"];

      for (const pattern of testPatterns) {
        const parsedUrl = new URL(url);
        parsedUrl.searchParams.set('id', pattern);

        const response = await axios.get(parsedUrl.toString(), {
          validateStatus: () => true,
          timeout: 5000
        });

        const body = response.data ? response.data.toString().toLowerCase() : '';

        // Look for SQL error messages
        const sqlErrors = [
          'sql syntax',
          'mysql',
          'postgresql',
          'sqlite',
          'ora-',
          'syntax error',
          'unclosed quotation',
          'quoted string not properly terminated'
        ];

        for (const errorPattern of sqlErrors) {
          if (body.includes(errorPattern)) {
            this.addFinding('Potential SQL Injection', 'High',
              `SQL error message detected in response. Application may be vulnerable to SQL injection.`);
            return; // Don't report multiple times
          }
        }
      }

    } catch (error) {
      console.error(`[${this.name}] SQL injection test failed:`, error.message);
    }
  }

  /**
   * Test cookie security attributes
   */
  async testCookieSecurity(url) {
    try {
      const response = await axios.get(url, {
        validateStatus: () => true,
        timeout: 5000
      });

      const cookies = response.headers['set-cookie'];
      if (!cookies) return;

      const cookieArray = Array.isArray(cookies) ? cookies : [cookies];

      cookieArray.forEach(cookie => {
        const lowerCookie = cookie.toLowerCase();

        if (!lowerCookie.includes('httponly')) {
          this.addFinding('Cookie Missing HttpOnly Flag', 'Medium',
            `Cookie without HttpOnly flag is accessible via JavaScript: ${cookie.split(';')[0]}`);
        }

        if (!lowerCookie.includes('secure')) {
          this.addFinding('Cookie Missing Secure Flag', 'Medium',
            `Cookie without Secure flag can be transmitted over HTTP: ${cookie.split(';')[0]}`);
        }

        if (!lowerCookie.includes('samesite')) {
          this.addFinding('Cookie Missing SameSite Attribute', 'Low',
            `Cookie without SameSite attribute may be vulnerable to CSRF: ${cookie.split(';')[0]}`);
        }
      });

    } catch (error) {
      console.error(`[${this.name}] Cookie security test failed:`, error.message);
    }
  }

  /**
   * Add a finding to the results
   */
  addFinding(title, severity, description) {
    this.findings.push({
      title,
      severity,
      description,
      timestamp: new Date().toISOString()
    });
  }

  /**
   * Calculate overall risk level
   */
  calculateRiskLevel(findings) {
    if (!findings || findings.length === 0) return 'Low';

    const hasHigh = findings.some(f => f.severity === 'High');
    const hasMedium = findings.some(f => f.severity === 'Medium');

    if (hasHigh) return 'High';
    if (hasMedium) return 'Medium';
    return 'Low';
  }
}

module.exports = VulnerabilityTool;
