const express = require('express');
const PenTestAgent = require('../agents/pentestAgent');

const router = express.Router();

/**
 * POST /api/pentest
 * Run a penetration test on a target URL
 *
 * Request body:
 * {
 *   "url": "https://example.com",
 *   "format": "json" | "text" (optional, defaults to "json")
 * }
 */
router.post('/pentest', async (req, res) => {
  try {
    const { url, format = 'json' } = req.body;

    // Validate request
    if (!url) {
      return res.status(400).json({
        error: 'Missing required field: url',
        example: { url: 'https://example.com' }
      });
    }

    // Get Groq API key from environment
    const apiKey = process.env.GROQ_API_KEY;
    if (!apiKey) {
      return res.status(500).json({
        error: 'Server configuration error: GROQ_API_KEY not set'
      });
    }

    // Initialize agent and run test
    const agent = new PenTestAgent(apiKey);
    const report = await agent.runPenTest(url);

    // Return report in requested format
    if (format === 'text') {
      const textReport = formatReportAsText(report);
      res.set('Content-Type', 'text/plain');
      return res.send(textReport);
    }

    // Default: JSON format
    res.json(report);

  } catch (error) {
    console.error('[Route] Error in /api/pentest:', error);
    res.status(500).json({
      error: 'Internal server error',
      message: error.message
    });
  }
});

/**
 * GET /api/health
 * Health check endpoint
 */
router.get('/health', async (req, res) => {
  try {
    const apiKey = process.env.GROQ_API_KEY;

    if (!apiKey) {
      return res.status(500).json({
        status: 'unhealthy',
        reason: 'GROQ_API_KEY not configured'
      });
    }

    const agent = new PenTestAgent(apiKey);
    const health = await agent.healthCheck();

    res.json({
      status: health.status,
      groq: health.groqAvailable ? 'connected' : 'unavailable',
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    res.status(500).json({
      status: 'unhealthy',
      error: error.message
    });
  }
});

/**
 * Format report as plain text
 */
function formatReportAsText(report) {
  let text = '';

  text += '═══════════════════════════════════════════════════\n';
  text += '       PENETRATION TEST REPORT\n';
  text += '═══════════════════════════════════════════════════\n\n';

  text += `Target: ${report.target}\n`;
  text += `Timestamp: ${report.timestamp}\n`;
  text += `Risk Level: ${report.riskLevel}\n`;
  text += `Total Findings: ${report.totalFindings}\n\n`;

  text += '───────────────────────────────────────────────────\n';
  text += 'EXECUTIVE SUMMARY\n';
  text += '───────────────────────────────────────────────────\n';
  text += `${report.summary}\n\n`;

  if (report.riskAssessment) {
    text += `Risk Assessment: ${report.riskAssessment}\n\n`;
  }

  if (report.criticalFindings && report.criticalFindings.length > 0) {
    text += '───────────────────────────────────────────────────\n';
    text += 'CRITICAL FINDINGS\n';
    text += '───────────────────────────────────────────────────\n';
    report.criticalFindings.forEach((finding, i) => {
      text += `${i + 1}. ${finding}\n`;
    });
    text += '\n';
  }

  if (report.findings && report.findings.length > 0) {
    text += '───────────────────────────────────────────────────\n';
    text += 'DETAILED FINDINGS\n';
    text += '───────────────────────────────────────────────────\n';
    report.findings.forEach((finding, i) => {
      text += `\n[${i + 1}] ${finding.title}\n`;
      text += `Severity: ${finding.severity}\n`;
      text += `Description: ${finding.description}\n`;
    });
    text += '\n';
  }

  if (report.recommendations && report.recommendations.length > 0) {
    text += '───────────────────────────────────────────────────\n';
    text += 'RECOMMENDATIONS\n';
    text += '───────────────────────────────────────────────────\n';
    report.recommendations.forEach((rec, i) => {
      text += `${i + 1}. ${rec}\n`;
    });
    text += '\n';
  }

  text += '═══════════════════════════════════════════════════\n';
  text += `Generated by: ${report.generatedBy}\n`;
  text += '═══════════════════════════════════════════════════\n';

  return text;
}

module.exports = router;
