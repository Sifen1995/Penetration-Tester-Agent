const Groq = require('groq-sdk');
const ReconTool = require('../tools/reconTool');
const VulnerabilityTool = require('../tools/vulnerabilityTool');

/**
 * PenTest Agent
 * Orchestrates security testing using reconnaissance, vulnerability scanning,
 * and AI-powered analysis via Groq API
 */

class PenTestAgent {
  constructor(apiKey) {
    if (!apiKey) {
      throw new Error('Groq API key is required');
    }

    this.groq = new Groq({ apiKey });
    this.reconTool = new ReconTool();
    this.vulnerabilityTool = new VulnerabilityTool();
    this.model = 'llama-3.3-70b-versatile'; // or 'mixtral-8x7b-32768'
  }

  /**
   * Perform complete penetration test
   * @param {string} url - Target URL
   * @returns {Promise<Object>} Complete test report
   */
  async runPenTest(url) {
    try {
      console.log(`\n=== Starting PenTest Agent for ${url} ===\n`);

      // Validate URL
      this.validateUrl(url);

      // Step 1: Reconnaissance
      console.log('[Agent] Phase 1: Reconnaissance');
      const reconData = await this.reconTool.scan(url);

      if (reconData.error) {
        return this.generateErrorReport(url, reconData.error);
      }

      // Step 2: Vulnerability Scanning
      console.log('[Agent] Phase 2: Vulnerability Scanning');
      const vulnData = await this.vulnerabilityTool.scan(url, reconData);

      // Step 3: AI Analysis
      console.log('[Agent] Phase 3: AI-Powered Analysis');
      const analysis = await this.analyzeWithGroq(reconData, vulnData);

      // Step 4: Generate Final Report
      console.log('[Agent] Phase 4: Generating Report');
      const report = this.generateReport(url, reconData, vulnData, analysis);

      console.log('\n=== PenTest Agent Completed ===\n');
      return report;

    } catch (error) {
      console.error('[Agent] Error during penetration test:', error);
      return this.generateErrorReport(url, error.message);
    }
  }

  /**
   * Validate URL format
   */
  validateUrl(url) {
    try {
      const parsed = new URL(url);
      if (!['http:', 'https:'].includes(parsed.protocol)) {
        throw new Error('URL must use HTTP or HTTPS protocol');
      }
    } catch (error) {
      throw new Error(`Invalid URL: ${error.message}`);
    }
  }

  /**
   * Analyze findings using Groq AI
   */
  async analyzeWithGroq(reconData, vulnData) {
    try {
      const prompt = this.buildAnalysisPrompt(reconData, vulnData);

      const completion = await this.groq.chat.completions.create({
        messages: [
          {
            role: 'system',
            content: `You are a professional penetration testing analyst. Your role is to analyze security scan results and provide:
1. A concise executive summary of findings
2. Prioritized list of vulnerabilities
3. Practical, actionable recommendations
4. Risk assessment

Format your response as JSON with the following structure:
{
  "summary": "Brief overview of security posture",
  "criticalFindings": ["list of critical issues"],
  "recommendations": ["prioritized list of fixes"],
  "riskAssessment": "Overall risk level and explanation"
}`
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        model: this.model,
        temperature: 0.3,
        max_tokens: 2000,
        response_format: { type: 'json_object' }
      });

      const responseText = completion.choices[0]?.message?.content;
      return JSON.parse(responseText || '{}');

    } catch (error) {
      console.error('[Agent] Groq analysis error:', error.message);
      return {
        summary: 'AI analysis unavailable',
        criticalFindings: [],
        recommendations: ['Manual review recommended'],
        riskAssessment: 'Unable to assess'
      };
    }
  }

  /**
   * Build prompt for Groq analysis
   */
  buildAnalysisPrompt(reconData, vulnData) {
    const securityPosture = this.reconTool.analyzeSecurityPosture(reconData);

    return `Analyze this web application security scan:

TARGET: ${reconData.url}

RECONNAISSANCE DATA:
- Server: ${reconData.serverInfo?.server || 'Unknown'}
- Technology: ${reconData.serverInfo?.poweredBy || 'Unknown'}
- Tech Stack: ${reconData.techStack?.join(', ') || 'Not detected'}

SECURITY HEADERS:
${JSON.stringify(reconData.securityHeaders, null, 2)}

VULNERABILITIES FOUND (${vulnData.vulnerabilities?.length || 0}):
${JSON.stringify(vulnData.vulnerabilities, null, 2)}

RISK LEVEL: ${vulnData.riskLevel}

Please provide a professional security analysis with summary, critical findings, recommendations, and risk assessment.`;
  }

  /**
   * Generate final report
   */
  generateReport(url, reconData, vulnData, analysis) {
    return {
      target: url,
      timestamp: new Date().toISOString(),

      // Executive Summary (from AI)
      summary: analysis.summary || 'Security scan completed',

      // Overall Risk
      riskLevel: vulnData.riskLevel,
      riskAssessment: analysis.riskAssessment,

      // Detailed Findings
      findings: vulnData.vulnerabilities || [],
      totalFindings: vulnData.vulnerabilities?.length || 0,

      // Critical Issues (from AI)
      criticalFindings: analysis.criticalFindings || [],

      // Recommendations (from AI)
      recommendations: analysis.recommendations || [],

      // Technical Details
      technicalDetails: {
        reconnaissance: {
          server: reconData.serverInfo,
          techStack: reconData.techStack,
          headers: reconData.securityHeaders
        },
        vulnerabilityScan: {
          testsPerformed: vulnData.testsPerformed,
          riskLevel: vulnData.riskLevel
        }
      },

      // Metadata
      generatedBy: 'PenTester Agent v1.0',
      scanDuration: 'N/A'
    };
  }

  /**
   * Generate error report
   */
  generateErrorReport(url, errorMessage) {
    return {
      target: url,
      timestamp: new Date().toISOString(),
      error: errorMessage,
      summary: `Failed to complete security scan: ${errorMessage}`,
      riskLevel: 'Unknown',
      findings: [],
      recommendations: [
        'Verify the target URL is accessible',
        'Check network connectivity',
        'Ensure proper permissions for security testing'
      ],
      generatedBy: 'PenTester Agent v1.0'
    };
  }

  /**
   * Quick health check
   */
  async healthCheck() {
    try {
      const completion = await this.groq.chat.completions.create({
        messages: [{ role: 'user', content: 'Say "OK"' }],
        model: this.model,
        max_tokens: 10
      });
      return { status: 'healthy', groqAvailable: true };
    } catch (error) {
      return { status: 'unhealthy', groqAvailable: false, error: error.message };
    }
  }
}

module.exports = PenTestAgent;
